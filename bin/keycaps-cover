#!/usr/bin/env python3
"""Check that a set of kits covers a particular keyboard.
"""
__author__ = 'Martin Blais <blais@furius.ca>'

import argparse
import itertools
import io
import logging
import sys

from keycaps import colors
from keycaps import keyio
from keycaps import keycaps_pb2
from google.protobuf import text_format


def read_kit(filename):
    kit = keyio.read_file(filename, keycaps_pb2.Kit)
    for key in kit.cap:
        for name in 'profile', 'stem', 'material':
            if not key.HasField(name):
                setattr(key, name, getattr(kit.set, name))
        yield key


CSS = """

.key {
  border: thin solid black;
  margin: 3px;
  padding: 2px;
}

.tooltip .tooltiptext {
  visibility: hidden;
  width: 1024px;
  background-color: black;
  color: #fff;
  text-align: center;
  border-radius: 6px;
  padding: 5px 0;

  /* Position the tooltip */
  position: absolute;
  z-index: 1;
}

.tooltip:hover .tooltiptext {
  visibility: visible;
}

.leftover {
  border-style: dashed;
  border-width: medium;
}
"""


TEMPLATE = """\
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Layout Key Assignment</title>
    <style type="text/css">
{style}
    </style>
  </head>
  <body>
{keys}
  </body>
</html>
"""

KEY = """
    <div class="key tooltip {cls}"
         style="position: absolute; left: {left}px; top: {top}px; width: {width}px; height: {height}px; background-color: {color}">
      {text}
      <span class="tooltiptext">{tiptext}</span>
    </div>
"""


# The width of a key along its main direction.
SIZE_WIDTH = {
    keycaps_pb2.U100: 4,
    keycaps_pb2.U125: 5,
    keycaps_pb2.U150: 6,
    keycaps_pb2.U175: 7,
    keycaps_pb2.U200: 8,
    keycaps_pb2.U225: 9,
    keycaps_pb2.U250: 10,
    keycaps_pb2.U275: 11,
    keycaps_pb2.U300: 12,
    keycaps_pb2.U600: 24,
    keycaps_pb2.U625: 25,
    keycaps_pb2.U625S: 25,
    keycaps_pb2.U625U: 25,
    keycaps_pb2.U700: 28,
    keycaps_pb2.V200: 8,
    keycaps_pb2.VISO: None,
}



def fill_positions(keyboard):
    """Fill in the position of the individual switches from its clusters.

    Args:
      keyboard: An instance of Keyboard.
    Returns:
      A copy of 'keyboard' with the x,y coordinates on all the switches resolved
      from their parent clusters.
    """
    output = keycaps_pb2.Keyboard()
    output.CopyFrom(keyboard)
    for cluster in output.cluster:
        x = cluster.x
        y = cluster.y
        for switch in cluster.switch:
            if not switch.HasField('x'):
                switch.x = x
            if not switch.HasField('y'):
                switch.y = y
            if not switch.HasField('row'):
                switch.row = cluster.row
            x += SIZE_WIDTH[switch.size]
    return output


def main():
    parser = argparse.ArgumentParser(description=__doc__.strip())
    parser.add_argument('keyboard', help='Keyboard filename')
    parser.add_argument('kits', nargs='+', help='Filenames of all kits')
    args = parser.parse_args()

    allkeys = list(itertools.chain.from_iterable(read_kit(filename)
                                                 for filename in args.kits))

    # Read the target keyboard layout file we have to cover.
    keyboard_ = keyio.read_file(args.keyboard, keycaps_pb2.Keyboard)

    # Fill in the position of the individual switches from its clusters.
    keyboard = fill_positions(keyboard_)

    # Try to find a matching key, first for switches with a role, then for
    # switches with no role. Row must always match.
    keys = list(allkeys)

    switches = [switch
                for cluster in keyboard.cluster
                for switch in cluster.switch]
    matches = []
    for i, (hasrole, func) in enumerate([(True, lambda s: bool(s.role)),
                                         (True, lambda s: not bool(s.role)),
                                         (False, lambda s: True)]):
        if not switches:
            break
        nswitches = []
        for switch in switches:
            if not func(switch):
                nswitches.append(switch)
                continue
            tr = (SIZE_WIDTH[switch.size],
                  switch.role if hasrole else None,
                  switch.row)
            delete = []
            for index, key in enumerate(keys):
                sr = (SIZE_WIDTH[key.size],
                      key.role if hasrole else None,
                      key.row)
                if sr == tr:
                    matches.append((switch, key))
                    delete.append(index)
                    break
            else:
                nswitches.append(switch)
            for index in delete:
                del keys[index]
        switches = nswitches

    for switch in switches:
        logging.error("Could not find key for switch: {}".format(
            text_format.MessageToString(switch, as_one_line=True)))

    ## FIXME: Remove
    if 0:
        # Print the list of succesfully matched keys.
        for switch, key in matches:
            print(text_format.MessageToString(switch, as_one_line=True))
            print(text_format.MessageToString(key, as_one_line=True))
            print()

    # Render some HTML of the assignment.
    U = 25
    margin = 5
    keysoss = io.StringIO()
    for switch, key in matches:
        keyoss = io.StringIO()
        keyoss.write("<p>SWITCH: ")
        keyoss.write(text_format.MessageToString(switch, as_one_line=True))
        keyoss.write("</p>\n")
        keyoss.write("<p>KEY: ")
        keyoss.write(text_format.MessageToString(key, as_one_line=True))
        keyoss.write("</p>\n")

        text = '<i>{}</i><br/><b>{}</b>'.format(switch.role, key.text)

        cls = ''
        if switch.role and key.role and switch.role != key.role:
            cls = 'leftover'

        keysoss.write(KEY.format(
            top=switch.y*U,
            left=switch.x*U,
            width=int(SIZE_WIDTH[switch.size]*U) - 2*margin,
            height=4*U - 2*margin,
            color=colors.get(key.color),
            text=text,
            tiptext=keyoss.getvalue(),
            cls=cls))

    print(TEMPLATE.format(style=CSS, keys=keysoss.getvalue()))


if __name__ == '__main__':
    main()
